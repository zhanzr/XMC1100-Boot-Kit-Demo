/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  *
  ******************************************************************************
  */
	
/* Includes ------------------------------------------------------------------*/
/* Private includes ----------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <limits.h>

#include <xmc_gpio.h>
#include <xmc_rtc.h>
#include "led.h"
#include "XMC1000_Tse.h"
#include "ring_buffer.h"
#include "serial.h"
#include "shell.h"

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "timers.h"

#include "FreeRTOS_CLI.h"

#ifdef CLOCKS_PER_SEC
#undef CLOCKS_PER_SEC
#define	CLOCKS_PER_SEC	configTICK_RATE_HZ
#endif

/* Private variables ---------------------------------------------------------*/
TaskHandle_t g_task01_handle;
TaskHandle_t g_task02_handle;
TaskHandle_t g_task_shell_handle;
SemaphoreHandle_t g_noti_sema;
SemaphoreHandle_t g_noti_sema_stdin;
QueueHandle_t g_queue;
TimerHandle_t g_timer;

RING_BUFFER_DEF(serial_buffer, SERIAL_BUFFER_SIZE);

extern int stdout_putchar (int ch);

/* Private function prototypes -----------------------------------------------*/
/* Determine whether we are in thread mode or handler mode. */
static inline int inHandlerMode (void)  __pure {
  return __get_IPSR() != 0;
}

void _clock_init( void ) {
	//No need to reinitialize the clock
}

uint32_t getKernelSysTick(void) {
  if (inHandlerMode()) {
    return xTaskGetTickCountFromISR();
  } else {
    return xTaskGetTickCount();
  }
}

clock_t clock( void ) {
	return getKernelSysTick();
}

void TimerCallback( xTimerHandle pxtimer ) {
	uint32_t ra = __return_address();
		
//	LED_Toggle(0);
}

void StartDefaultTask(void const * argument);
void StartTask02(void const * argument);
void vCommandConsoleTask( void *pvParameters );

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static BaseType_t prvTaskStatsCommand( int8_t *pcWriteBuffer,
                                          size_t xWriteBufferLen,
                                          const int8_t *pcCommandString ) {
    /* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
    ( void ) xWriteBufferLen;

    /* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
    generated by executing vTaskList() is written directly into the output
    buffer. */
    vTaskList( pcWriteBuffer );

    /* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
    return pdFALSE;
}

static BaseType_t prvRtcCommand( int8_t *pcWriteBuffer,
                                          size_t xWriteBufferLen,
                                          const int8_t *pcCommandString ) {
    /* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
    ( void ) xWriteBufferLen;

	__IO XMC_RTC_TIME_t now_rtc_time;
	
	XMC_RTC_GetTime((XMC_RTC_TIME_t *)&now_rtc_time);
	sprintf(pcWriteBuffer, "%02d:%02d:%02d\n", now_rtc_time.hours, now_rtc_time.minutes, now_rtc_time.seconds);

    /* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
    return pdFALSE;
}
																					
static BaseType_t prvDtsCommand( int8_t *pcWriteBuffer,
                                          size_t xWriteBufferLen,
                                          const int8_t *pcCommandString ) {
    /* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
    ( void ) xWriteBufferLen;

	int32_t tmp_i32 = (int32_t)XMC1000_CalcTemperature_soft();
	sprintf(pcWriteBuffer, "DTS:%i\n", tmp_i32 - 273);

    /* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
    return pdFALSE;
}
	
static BaseType_t prvLedCommand( int8_t *pcWriteBuffer,
                                     size_t xWriteBufferLen,
                                     const int8_t *pcCommandString ) {
	char *pcParameter1, *pcParameter2;
	BaseType_t xParameter1StringLength;
	BaseType_t xParameter2StringLength;
	BaseType_t xResult;
  
	pcParameter1 = (char*)FreeRTOS_CLIGetParameter(pcCommandString, 1, &xParameter1StringLength);
  pcParameter2 = (char*)FreeRTOS_CLIGetParameter(pcCommandString, 2, &xParameter2StringLength );

    /* Terminate both file names. */
    pcParameter1[ xParameter1StringLength ] = 0x00;
    pcParameter2[ xParameter2StringLength ] = 0x00;

    /* Perform the copy operation itself. */
		uint8_t tmp_num = (uint8_t)atoi(pcParameter1);
		if(tmp_num >= LED_TOTAL_NUM) {
			tmp_num = 0;
		}
		
		if (strcmp(pcParameter2, "on") == 0) {
			LED_On(tmp_num);	
		}	else if (strcmp(pcParameter2, "off") == 0) {
			LED_Off(tmp_num);	
		} else {
			sprintf(pcWriteBuffer, "Argument not supported\r\n");
			return pdFALSE;
		}
		
		*pcWriteBuffer = NULL;
    return pdFALSE;
}

static const CLI_Command_Definition_t xTestCommand = {
    "test",
    "test : test for FreeRTOS CLI\r\n",
    prvTaskStatsCommand,
    0
};

static const CLI_Command_Definition_t xRtcCommand = {
    "rtc",
    "rtc : Get RTC Value\r\n",
    prvRtcCommand,
    0
};

static const CLI_Command_Definition_t xDtsCommand = {
    "dts",
    "dts : Get DTS Value\r\n",
    prvDtsCommand,
    0
};

static const CLI_Command_Definition_t xLedCommand = {
    "led",
    "led : <led num> <on | off>\r\n",
    prvLedCommand,
    2
};
/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* Create the thread(s) */
  /* definition and creation of defaultTask */
	xTaskCreate((TaskFunction_t)StartDefaultTask,
							(const portCHAR *)"defaultTask",
							384,
							NULL,
							2,
							&g_task01_handle);

  /* definition and creation of myTask02 */
	xTaskCreate((TaskFunction_t)StartTask02,
							(const portCHAR *)"myTask02",
							64,
							NULL,
							3,
							&g_task02_handle);
							
//	xTaskCreate((TaskFunction_t)shell_task,
//							(const portCHAR *)"shell_task",
//							384,
//							NULL,
//							2,
//							&g_task_shell_handle);		
	xTaskCreate((TaskFunction_t)vCommandConsoleTask,
							(const portCHAR *)"vCommandConsoleTask",
							384,
							NULL,
							2,
							&g_task_shell_handle);		
							
	/* Create one Software Timer.*/
	g_timer = xTimerCreate("Timer", 
							2000/ portTICK_PERIOD_MS,
							pdTRUE,
							0,
							TimerCallback);
	xTimerStart( g_timer, 0);
						 
	FreeRTOS_CLIRegisterCommand( &xTestCommand );
	FreeRTOS_CLIRegisterCommand( &xRtcCommand );
	FreeRTOS_CLIRegisterCommand( &xDtsCommand );
	FreeRTOS_CLIRegisterCommand( &xLedCommand );
							
	/* Create the notification semaphore and set the initial state. */
	vSemaphoreCreateBinary(g_noti_sema);
	vQueueAddToRegistry(g_noti_sema, "Notification Semaphore");
	xSemaphoreTake(g_noti_sema, 0);
	
	vSemaphoreCreateBinary(g_noti_sema_stdin);
	vQueueAddToRegistry(g_noti_sema_stdin, "STDIN Semaphore");
//	xSemaphoreTake(g_noti_sema_stdin, 0);
	
	/* Create a queue*/
	g_queue = xQueueCreate(2, sizeof(uint32_t));
}

#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100

static const int8_t * const pcWelcomeMessage =
  "FreeRTOS command server.\r\nType Help to view a list of registered commands.\r\n";

void vCommandConsoleTask( void *pvParameters ) {
	int8_t cRxedChar, cInputIndex = 0;
BaseType_t xMoreDataToFollow;
/* The input and output buffers are declared static to keep them off the stack. */
static int8_t pcOutputString[ MAX_OUTPUT_LENGTH ], pcInputString[ MAX_INPUT_LENGTH ];  	
	printf(pcWelcomeMessage);			
	printf(SHELL_PROMPT);			
	fflush(stdout);
	
    for( ;; )
    {
        /* This implementation reads a single character at a time.  Wait in the
        Blocked state until a character is received. */
				xSemaphoreTake(g_noti_sema_stdin, portMAX_DELAY);	
				
				if (ring_buffer_avail(&serial_buffer) > 0) {
						cRxedChar = getchar();	
						
					if( cRxedChar == '\n' )
					{
							/* A newline character was received, so the input command string is
							complete and can be processed.  Transmit a line separator, just to
							make the output easier to read. */
							printf("\r\n");			
							fflush(stdout);
							/* The command interpreter is called repeatedly until it returns
							pdFALSE.  See the "Implementing a command" documentation for an
							exaplanation of why this is. */
							do
							{
									/* Send the command string to the command interpreter.  Any
									output generated by the command interpreter will be placed in the
									pcOutputString buffer. */
									xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
																		pcInputString,   /* The command string.*/
																		pcOutputString,  /* The output buffer. */
																		MAX_OUTPUT_LENGTH/* The size of the output buffer. */
																);

									/* Write the output generated by the command interpreter to the
									console. */
									printf(pcOutputString);			
							} while( xMoreDataToFollow != pdFALSE );
							printf(SHELL_PROMPT);			
							fflush(stdout);
							
							/* All the strings generated by the input command have been sent.
							Processing of the command is complete.  Clear the input string ready
							to receive the next command. */
							cInputIndex = 0;
							memset( pcInputString, 0x00, MAX_INPUT_LENGTH );
					} else {
							/* The if() clause performs the processing after a newline character
							is received.  This else clause performs the processing if any other
							character is received. */
							if( cRxedChar == '\r' ) {
									/* Ignore carriage returns. */
							} else if( cRxedChar == '\b' ) {
									/* Backspace was pressed.  Erase the last character in the input
									buffer - if there are any. */
									if( cInputIndex > 0 ) {
											cInputIndex--;
											pcInputString[ cInputIndex ] = '\0';
									}
							} else {
									/* A character was entered.  It was not a new line, backspace
									or carriage return, so it is accepted as part of the input and
									placed into the input buffer.  When a n is entered the complete
									string will be passed to the command interpreter. */
									if( cInputIndex < MAX_INPUT_LENGTH ) {										
										pcInputString[ cInputIndex ] = cRxedChar;
										cInputIndex++;																					
										stdout_putchar((char)cRxedChar);
									}
							}
					}
				}
    }
}
		
void vApplicationIdleHook( void ) {
}

extern void __Vectors(void);

extern void __Vectors_End;
#define __STEXT	(void(*)(void))&__Vectors_End
extern void Region$$Table$$Limit;
#define __ETEXT ((void(*)(void))&Region$$Table$$Limit) 
	
extern void __Vectors_Size(void);

/**
  * @brief  Function implementing the defaultTask thread.
  * @param  argument: Not used 
  * @retval None
  */
void StartDefaultTask(void const * argument) {
	uint32_t tmpTicks;	
		
	__yield();
	
  /* Infinite loop */
  for(;;) {
		xQueueReceive(g_queue, &tmpTicks, portMAX_DELAY);
		
//		printf("%s %u %u %u\n", 
//		tskKERNEL_VERSION_NUMBER,
//		tmpTicks,
//		SystemCoreClock,
//		__clz(tmpTicks)
//		);
//	
		xSemaphoreTake(g_noti_sema, portMAX_DELAY);	

//		char tmpBuf[1024];
//		vTaskList(tmpBuf);
//		printf(tmpBuf);
//		
//		printf("Total Heap:%u\n", 
//		configTOTAL_HEAP_SIZE);
//		
//		printf("Free Heap:%u\n",
//		xPortGetFreeHeapSize());
//				
//		printf("minimum ever:%u\n",
//		xPortGetMinimumEverFreeHeapSize());
//		
//		printf("vect: %p vect_end: %p table_limit: %p\n", __Vectors, __STEXT, __ETEXT);
//		printf("vect_size: %p\n", __Vectors_Size);
//		printf("Reset_Handler: %p\n", Reset_Handler);
//		printf("__main: %p\n", __main);
//		printf("_clock_init: %p\n", _clock_init);
//        
//		printf("%u %u\n", CLOCKS_PER_SEC, clock());
						
//		vTaskGetRunTimeStats(tmpBuf);
//		printf(tmpBuf);		

//		printf("\n");
  }
}

/**
* @brief Function implementing the myTask02 thread.
* @param argument: Not used
* @retval None
*/
void StartTask02(void const * argument) {
	uint32_t ra = __return_address();
  /* Infinite loop */
  for(;;) {
		LED_Toggle(2);

		xSemaphoreGive(g_noti_sema);		
		
		uint32_t tmpTick = getKernelSysTick();
		xQueueSend(g_queue, &tmpTick, 0);

    vTaskDelay(2000 / portTICK_PERIOD_MS);
  }
}

